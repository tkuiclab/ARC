<html lang="en">
  <head>
    <title>Ducplicate Quaternino from Python</title>

	</head>
<body>

  <script src="numjs.min.js"></script>
  <script src="Math.js"></script>
   <script src="euler_quaternion_converter.js"></script>

  <script>
  var l = console.log;
  var w = document.write;
  // epsilon for testing whether a number is close to zero
  var EPS = 4e-16;
  var _AXES2TUPLE = {
    'sxyz': [0, 0, 0, 0], 'sxyx': [0, 0, 1, 0], 'sxzy': [0, 1, 0, 0],
    'sxzx': [0, 1, 1, 0], 'syzx': [1, 0, 0, 0], 'syzy': [1, 0, 1, 0],
    'syxz': [1, 1, 0, 0], 'syxy': [1, 1, 1, 0], 'szxy': [2, 0, 0, 0],
    'szxz': [2, 0, 1, 0], 'szyx': [2, 1, 0, 0], 'szyz': [2, 1, 1, 0],
    'rzyx': [0, 0, 0, 1], 'rxyx': [0, 0, 1, 1], 'ryzx': [0, 1, 0, 1],
    'rxzx': [0, 1, 1, 1], 'rxzy': [1, 0, 0, 1], 'ryzy': [1, 0, 1, 1],
    'rzxy': [1, 1, 0, 1], 'ryxy': [1, 1, 1, 1], 'ryxz': [2, 0, 0, 1],
    'rzxz': [2, 0, 1, 1], 'rxyz': [2, 1, 0, 1], 'rzyz': [2, 1, 1, 1]}

  // axis sequences for Euler angles
  var _NEXT_AXIS = [1, 2, 0, 1];
 /*
  function euler_from_matrix(matrix, axes='sxyz'){

      //[firstaxis, parity, repetition, frame] = _AXES2TUPLE[axes.lower()];

      l('_AXES2TUPLE[axes.lower()]'+_AXES2TUPLE[axes]);
      var firstaxis =_AXES2TUPLE[axes][0];
      var parity =_AXES2TUPLE[axes][1];
      var repetition =_AXES2TUPLE[axes][2];
      var frame =_AXES2TUPLE[axes][3];


      // try:
      //     firstaxis, parity, repetition, frame = _AXES2TUPLE[axes.lower()]
      // except (AttributeError, KeyError):
      //     _ = _TUPLE2AXES[axes]
      //     firstaxis, parity, repetition, frame = axes



      i = firstaxis;
      j = _NEXT_AXIS[i+parity];
      k = _NEXT_AXIS[i-parity+1];

      //var M = nj.array(matrix, dtype='float64', copy=False).reshape(3,3);
      var M = nj.array( [ [ matrix.get(0,0),matrix.get(0,1), matrix.get(0,2)],
                          [ matrix.get(1,0),matrix.get(1,1), matrix.get(1,2)],
                          [ matrix.get(2,0),matrix.get(2,1), matrix.get(2,2)] ]);
      //var M = matrix.reshape(3,3);
      l('M='+M);



      var ax,ay,az;

      if(repetition){
          sy = Math.sqrt(M.get(i, j)*M.get(i, j) + M.get(i, k)*M.get(i, k));
          if(sy > EPS){
              ax = Math.atan2( M.get(i, j),  M.get(i, k));
              ay = Math.atan2( sy,       M.get(i, i));
              az = Math.atan2( M.get(j, i), -M.get(k, i));
          }else{
              ax = Math.atan2(-M.get(j, k),  M.get(j, j));
              ay = Math.atan2( sy,       M.get(i, i));
              az = 0.0;
          }
      }else{
          cy = Math.sqrt(M.get(i, i)*M.get(i, i) + M.get(j, i)*M.get(j, i))
          if (cy > EPS){
              ax = Math.atan2( M.get(k, j),  M.get(k, k));
              ay = Math.atan2(-M.get(k, i),  cy);
              az = Math.atan2( M.get(j, i),  M.get(i, i));
          }else{
              ax = Math.atan2(-M.get(j, k),  M.get(j, j));
              ay = Math.atan2(-M.get(k, i),  cy);
              az = 0.0;
          }
      }
      if(parity){
          [ax, ay, az] = [-ax, -ay, -az];
      }
      if(frame){
          [ax, az] = [az, ax];
      }
      return [ax, ay, az];


  }

  function quaternion_matrix(quaternion){

      var q = nj.array(quaternion, dtype='float64').reshape(1,4);

      var nq = nj.dot(q, q.T);

      //l('nq='+nq+',shape='+nq.shape);
      //l('nq(0)='+nq(0));
      //l('nq.get(0,0)='+nq.get(0,0));

      if(nq < EPS){
           return nj.identity(4);
      }
      var sqrt_2_div_nq = Math.sqrt(2.0 / nq.get(0,0));
      //l('sqrt_2_div_nq='+sqrt_2_div_nq);
      //l('q='+q);
      q = nj.multiply(q,sqrt_2_div_nq);
      //q = q * sqrt_2_div_nq;
      //l('q='+q+',shape='+q.shape);
      //l('q.T='+q.T);


      // var q_4_1 = q.reshape(4,1);
      // l('q_4_1='+q_4_1+',shape='+q.shape);
      // l('q='+q+',shape='+q.shape);

      var q_outer = nj.dot(q.T, q);

      //l('q_outer='+q_outer);
      var q_m = nj.array([
          [1.0-q_outer.get(1, 1)-q_outer.get(2, 2),     q_outer.get(0, 1)-q_outer.get(2, 3),     q_outer.get(0, 2)+q_outer.get(1, 3), 0.0],
          [    q_outer.get(0, 1)+q_outer.get(2, 3), 1.0-q_outer.get(0, 0)-q_outer.get(2, 2),     q_outer.get(1, 2)-q_outer.get(0, 3), 0.0],
          [    q_outer.get(0, 2)-q_outer.get(1, 3),     q_outer.get(1, 2)+q_outer.get(0, 3), 1.0-q_outer.get(0, 0)-q_outer.get(1, 1), 0.0],
          [                0.0,                 0.0,                 0.0, 1.0]
        ],  dtype='float64');

     l('q_m='+q_m);

      // return numpy.array((
      //     (1.0-q[1, 1]-q[2, 2],     q[0, 1]-q[2, 3],     q[0, 2]+q[1, 3], 0.0),
      //     (    q[0, 1]+q[2, 3], 1.0-q[0, 0]-q[2, 2],     q[1, 2]-q[0, 3], 0.0),
      //     (    q[0, 2]-q[1, 3],     q[1, 2]+q[0, 3], 1.0-q[0, 0]-q[1, 1], 0.0),
      //     (                0.0,                 0.0,                 0.0, 1.0)
      //     ), dtype=numpy.float64)

      return q_m;
  }

  function euler_fomr_quaternion(quaternion){
     var q_m = quaternion_matrix(quaternion);
     return euler_from_matrix(q_m);
  }
  */
  var x = 0.282022538161;
  var y = 0.157035464967;
  var z = 0.0680701333135;
  var w = 0.944017800501;

//   var q_m = quaternion_matrix([x,y,z,w]);
//   var e_m = euler_from_matrix(q_m);
//   var e_m = euler_from_matrix(q_m);
  var e_m = euler_fomr_quaternion([x,y,z,w]);

document.write('Use function<BR>');
  document.write('roll  = '+e_m[0]*_Math.RAD2DEG+'<BR>');
  document.write('pitch = '+e_m[1]*_Math.RAD2DEG+'<BR>');
  document.write('yaw   = '+e_m[2]*_Math.RAD2DEG+'<BR>');

  var q2 = quaternion_from_euler(e_m[0], e_m[1], e_m[2]);
  l('q2='+q2);

  </script>

  </body>
</html>
